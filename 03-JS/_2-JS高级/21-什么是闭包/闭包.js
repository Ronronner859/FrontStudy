// 闭包：函数嵌套函数，内部函数可以访问外部函数的变量
// 闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕后，会从执行栈上移除，但是堆上的作用域不会被移除
// 闭包的应用：1.函数防抖和节流 2.闭包的私有变量

// 1，普通函数 记录函数被调用的次数

let count = 0;

function fn() {
    count++;
    console.log(count);
}
fn()
// count 是全局变量，可以被外部访问和修改，不安全

// 2，闭包 记录函数被调用的次数
function fn2() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    }
}
let f = fn2();
f()
// f 是一个闭包，count 是私有变量，只能被内部访问和修改，安全

// 应用：闭包实现数据的私有化
// 例如：节流和防抖
// 可能出现的问题：内存泄漏

// 从广义上来说任何函数都有可能是闭包，从狭义上来说当函数引用了外部变量，就会形成闭包；闭包的作用延长了变量的生命周期，因为GC会定期回收没有引用指向的变量，如果函数引用了某一个外部变量，GC在回收时会发现这个变量被引用着就不会回收掉，反之会被回收，从而延长了变量的生命周期，但是这样也会带来一个问题就是内存泄漏，所谓内存泄露就是有一些变量，我们只使用了一次，本该被释放掉腾出内存，但是没有被释放，内存资源被占用。这也就是为什么说使用闭包有可能造成内存泄露，如果只使用一次，就是内存泄漏，如果这个变量还有其他函数使用或被多次使用就不叫内存泄漏。为了防止内存泄露可以手动将变量清零null